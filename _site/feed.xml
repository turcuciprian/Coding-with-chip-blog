<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-27T20:25:47+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Coding With Chip - Blog</title><subtitle>The scripts from the youtube channel and more, in text format, with updated code and documentation</subtitle><entry><title type="html">Multiple Dicom MRIs to jpeg</title><link href="http://localhost:4000/python/machine-learning/2023/03/26/multiple-dicom-mris-to-jpeg.html" rel="alternate" type="text/html" title="Multiple Dicom MRIs to jpeg" /><published>2023-03-26T00:00:00+02:00</published><updated>2023-03-26T00:00:00+02:00</updated><id>http://localhost:4000/python/machine-learning/2023/03/26/multiple-dicom-mris-to-jpeg</id><content type="html" xml:base="http://localhost:4000/python/machine-learning/2023/03/26/multiple-dicom-mris-to-jpeg.html"><![CDATA[<p>Here’s the code for handling multiple MRI folders with DICOM mri images and how to save them into jpegs in organized folders</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from genericpath import isfile
from medpy.io import load
import matplotlib.pyplot as plt
import os
def final_dir(path, start_level=1, level_skip=2):
    childfolders = os.listdir(path)
    if len(childfolders)==0:
        return path, childfolders
    new_path = path+'/'+childfolders[0]
    start_level=start_level+1
    if(len(childfolders)&lt;level_skip):
        return final_dir(new_path, start_level)
    elif(start_level&gt;level_skip):
        return path, childfolders
    else:
        return final_dir(new_path, start_level)

# (path and child folders to write to, base destination path)
def create_folders( final_dir_data,exports_path = './images_exports',):
    # split to tupils PATH &amp; LIST OF CHILD FOLDERS
    path, child_folders = final_dir_data
    #Cycle trough child folders
    for folder in child_folders:
        # create path for child folder to write
        folder_path = exports_path+'/'+folder

        if not os.path.exists(folder_path):
            os.mkdir(folder_path)
    return path, child_folders





base_path = './MRI_images'
export_base_path = './images_exports'

# get first level Folders
first_level_path, first_level_folders = final_dir(base_path,1,1)
# create first level export folders //// with no returns
_, _ = create_folders((first_level_path,first_level_folders))
#--- get directories for final level paths
# cycle trough each folder
for folder in first_level_folders:
    # get the final level path and folders
    read_base_folders_path, write_to_folders = final_dir(first_level_path+'/'+folder,1)

    write_base_path = export_base_path+'/'+folder

    mri_image_destination_path, mri_image_destination_folders = create_folders((read_base_folders_path, write_to_folders),write_base_path)
    #write_base_path &gt; write_to_folders
    # print(write_base_path,write_to_folders,read_base_folders_path)
    folder_path = read_base_folders_path
    print(folder_path)
    for folder in write_to_folders:
        for image in os.listdir(folder_path+'/'+folder):
            # print(image)
            image_file_with_path = folder_path+'/'+folder+'/'+image
            if(os.path.isfile(image_file_with_path)== False):
                exit()
            try:
                image_data1= load(image_file_with_path)
                img = image_data1[0]
                plt.imshow(img)
                plt.savefig(write_base_path+'/'+folder+'/'+image+'.jpg')
                plt.close()
                print(write_base_path+'/'+folder+'/'+image+'.jpg')
            except ValueError:
                print ('ValueError: could not convert string to float: \'DataCamp\'')

</code></pre></div></div>]]></content><author><name></name></author><category term="python" /><category term="machine-learning" /><summary type="html"><![CDATA[Here’s the code for handling multiple MRI folders with DICOM mri images and how to save them into jpegs in organized folders]]></summary></entry><entry><title type="html">Event Channels in React Redux Saga Hooks</title><link href="http://localhost:4000/react/2023/03/26/react-redux-saga-hooks-events-channels.html" rel="alternate" type="text/html" title="Event Channels in React Redux Saga Hooks" /><published>2023-03-26T00:00:00+02:00</published><updated>2023-03-26T00:00:00+02:00</updated><id>http://localhost:4000/react/2023/03/26/react-redux-saga-hooks-events-channels</id><content type="html" xml:base="http://localhost:4000/react/2023/03/26/react-redux-saga-hooks-events-channels.html"><![CDATA[<p>In the tutorial available here: <a href="https://youtu.be/cTcThsNqqcg">https://youtu.be/cTcThsNqqcg</a>
I explain how eventChannels work using sockets ( a socket server ) and a react with redux hooks saga implementation.</p>

<h2 id="the-code">The code</h2>

<h3 id="server">Server</h3>

<p>the server app is just starting a socket server and emiting some strings every 3 seconds with the current value of the seconds of the server clock.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const express = require('express');
const app = express();
var cors = require('cors');
app.options('*', cors())
const http = require('http');
const httpServer = http.createServer(app);
const io = require("socket.io")(httpServer, {
  cors: {
    origin: "http://192.168.1.135:3000",
    methods: ["GET", "POST"],
    allowedHeaders: ["Access-Control-Allow-Origin"]
  },
  origins: ["http://192.168.1.135:3000"]
});


app.get('/', (req, res) =&gt; {
  res.sendFile(__dirname + '/index.html');
});
var intervalID;

io.on('connection', (socket) =&gt; {
  console.log('a user connected');
  clearInterval(intervalID);
  intervalID = setInterval(function () {
    console.log(new Date().getSeconds());
    socket.emit('seconds', new Date().getSeconds());
  }, 3000);
});

httpServer.listen(3001, () =&gt; {
  console.log('listening on *:3001');
});

</code></pre></div></div>

<h3 id="saga-code">Saga Code</h3>

<p>This is just the saga file containing the generator, but it’s the full file showing the eventChannel and socket implementation</p>

<p>For a full react Implementation with redux saga in hooks, as a previous project showing react redux saga with hooke, you can find</p>

<p>Meanwhile, here’s the code of the final saga file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { put, take, takeLatest, all, call } from "redux-saga/effects";
import { eventChannel, END } from 'redux-saga'
import { io } from "socket.io-client";
const receiveMessage = (socket) =&gt; {
  socket.on("disconnect", () =&gt; {
    socket.connect();
    console.log('socket disconnected');
  });
  return eventChannel((emitter) =&gt; {
    socket.on('seconds', (msg) =&gt; {
      emitter(msg);
    });
    return () =&gt; {
      emitter(END);
    }
  });
};

const runOurAction = function* () {
  const socket = io('http://192.168.1.135:3001');
  const chan = yield call(receiveMessage, socket);
  while (true) {
    try {
      const value = yield take(chan);
      yield put({ type: "SET_DATA", payload: value });
    } catch (err) {
      console.error('socket error:', err)
      // socketChannel is still open in catch block
      // if we want end the socketChannel, we need close it explicitly
      // socketChannel.close()
    }
  }
};
function* getAsyncDataWatcher() {
  yield takeLatest("GET_ASYNC_DATA", runOurAction);
}

export default function* rootSaga() {
  yield all([getAsyncDataWatcher()]);
}
</code></pre></div></div>

<h4 id="thats-all-folks">That’s all Folks!</h4>]]></content><author><name></name></author><category term="react" /><summary type="html"><![CDATA[In the tutorial available here: https://youtu.be/cTcThsNqqcg I explain how eventChannels work using sockets ( a socket server ) and a react with redux hooks saga implementation.]]></summary></entry></feed>